<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Memory Pattern Recorder V3</title>
    <style>
        :root { --primary: #ff6b6b; --bg: #f5f6fa; --text: #2f3640; }
        body { 
            font-family: 'Segoe UI', sans-serif; 
            background: var(--bg); 
            color: var(--text); 
            margin: 0; 
            padding: 10px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
        }
        
        .main-container { 
            background: white; 
            padding: 20px; 
            border-radius: 12px; 
            box-shadow: 0 4px 20px rgba(0,0,0,0.1); 
            max-width: 600px; 
            width: 100%; 
            box-sizing: border-box; 
        }

        /* HEADER & MENU */
        h2 { text-align: center; color: #2d3436; margin-top: 0; font-size: 1.2rem; }
        .nav-links { text-align: center; margin-bottom: 20px; font-size: 0.9rem; }
        .nav-links a { text-decoration: none; color: #636e72; margin: 0 5px; font-weight: bold; }
        .nav-links a.active { color: var(--primary); text-decoration: underline; }

        /* VIDEO PREVIEW */
        .preview-wrapper { 
            position: relative; 
            width: 100%; 
            background: #000; 
            border-radius: 8px; 
            overflow: hidden; 
            margin-bottom: 15px; 
            line-height: 0; 
        }
        #videoPlayer { width: 100%; display: block; }
        #overlayCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        /* CONTROLS */
        .control-panel { background: #fdfdfd; padding: 15px; border: 1px solid #eee; border-radius: 10px; margin-bottom: 15px; }
        .slider-row { margin-bottom: 12px; }
        .slider-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
        .slider-header label { font-size: 0.8rem; font-weight: bold; color: #636e72; }
        .val-badge { background: #eee; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; font-family: monospace; }
        input[type=range] { width: 100%; accent-color: var(--primary); cursor: pointer; }

        .action-btn { background: var(--primary); color: white; border: none; padding: 14px; border-radius: 8px; cursor: pointer; font-size: 1rem; width: 100%; font-weight: bold; transition: 0.2s; }
        .action-btn:disabled { background: #b2bec3; cursor: not-allowed; }

        /* FILE INPUT STYLE */
        input[type="file"] { width: 100%; margin-bottom: 15px; }
        ::file-selector-button { background: #eee; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-weight: bold; color: #555; margin-right: 10px; }

        /* RESULTS GRID (Video Mode usually 4x5) */
        .results-grid { 
            display: grid; 
            grid-template-columns: repeat(4, 1fr); 
            gap: 6px; 
            margin-top: 20px; 
            width: 100%;
        }
        .cell { 
            aspect-ratio: 1; 
            background: #f1f2f6; 
            border-radius: 6px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-weight: bold; 
            font-size: 1.2rem; 
            color: #bdc3c7; 
            border: 2px solid transparent; 
        }
        .cell.detected { 
            background: #fff0f0; 
            border-color: var(--primary); 
            color: var(--primary); 
            box-shadow: 0 4px 10px rgba(255, 107, 107, 0.2); 
        }

        #status { text-align: center; font-size: 0.85rem; margin: 10px 0; color: #636e72; }
    </style>
    <script async src="https://docs.opencv.org/4.5.4/opencv.js" onload="onOpenCvReady()"></script>
</head>
<body>

<div class="main-container">
    <div class="nav-links">
        <a href="index.html" class="active">Video Recorder</a> || 
        <a href="flipimage.html">Same Image Flip</a> || 
        <a href="sudokusolver.html">Sudoku Solver</a>
    </div>

    <h2>Video Pattern Analysis</h2>
    
    <input type="file" id="videoInput" accept="video/*">
    
    <div class="preview-wrapper">
        <video id="videoPlayer" muted playsinline></video>
        <canvas id="overlayCanvas"></canvas>
    </div>

    <div class="control-panel">
        <div class="slider-row">
            <div class="slider-header"><label>TOP MARGIN</label><span class="val-badge" id="v-t">23%</span></div>
            <input type="range" id="marginTop" min="0" max="50" value="23">
        </div>
        <div class="slider-row">
            <div class="slider-header"><label>BOTTOM MARGIN</label><span class="val-badge" id="v-b">15%</span></div>
            <input type="range" id="marginBottom" min="0" max="50" value="15">
        </div>
        <div class="slider-row">
            <div class="slider-header"><label>SIDE MARGIN</label><span class="val-badge" id="v-s">5%</span></div>
            <input type="range" id="marginSide" min="0" max="30" value="5">
        </div>
        
        <button id="processBtn" class="action-btn" disabled>â–¶ Start Analysis</button>
    </div>

    <div id="status">Loading OpenCV...</div>

    <div id="grid" class="results-grid">
        </div>

    <button id="btnDownload" class="action-btn" style="background:#2ecc71; margin-top:20px; display:none;">ðŸ’¾ Download Key Mapper JSON</button>
</div>

<canvas id="procCanvas" style="display:none;"></canvas>

<script>
let cvReady = false;
const ROWS = 5;
const COLS = 4;
let zones = []; 
let currentStep = 1;
let isProcessing = false;

// DOM Elements
const videoInput = document.getElementById('videoInput');
const videoPlayer = document.getElementById('videoPlayer');
const overlayCanvas = document.getElementById('overlayCanvas');
const overlayCtx = overlayCanvas.getContext('2d');
const procCanvas = document.getElementById('procCanvas');
const procCtx = procCanvas.getContext('2d', {willReadFrequently: true});
const gridEl = document.getElementById('grid');
const statusEl = document.getElementById('status');

// Initialize 20 Cells (4x5)
for(let i=0; i<20; i++) {
    let d = document.createElement('div');
    d.className = 'cell';
    d.id = `c-${i}`;
    d.innerText = i + 1;
    gridEl.appendChild(d);
}

function onOpenCvReady() {
    cvReady = true;
    statusEl.innerText = "Ready. Upload a video file.";
    loadSliderSettings();
}

// Sliders Logic
const sliders = ['marginTop', 'marginBottom', 'marginSide'];
sliders.forEach(id => {
    const el = document.getElementById(id);
    el.addEventListener('input', () => {
        updateBadge(id, el.value);
        saveSliderSettings();
        drawGridOverlay();
    });
});

function updateBadge(id, val) {
    const map = {'marginTop': 'v-t', 'marginBottom': 'v-b', 'marginSide': 'v-s'};
    if(map[id]) document.getElementById(map[id]).innerText = val + "%";
}

// --- LOCAL STORAGE ---
function saveSliderSettings() {
    const settings = {};
    sliders.forEach(id => settings[id] = document.getElementById(id).value);
    localStorage.setItem('videoRecorderSettings', JSON.stringify(settings));
}

function loadSliderSettings() {
    const saved = localStorage.getItem('videoRecorderSettings');
    if (saved) {
        const settings = JSON.parse(saved);
        Object.keys(settings).forEach(id => {
            const el = document.getElementById(id);
            if(el) {
                el.value = settings[id];
                updateBadge(id, el.value);
            }
        });
    }
}

// Video Loading
videoInput.addEventListener('change', (e) => {
    if(e.target.files[0]) {
        const url = URL.createObjectURL(e.target.files[0]);
        videoPlayer.src = url;
        videoPlayer.onloadedmetadata = () => {
             overlayCanvas.width = videoPlayer.videoWidth;
             overlayCanvas.height = videoPlayer.videoHeight;
             procCanvas.width = videoPlayer.videoWidth;
             procCanvas.height = videoPlayer.videoHeight;
             drawGridOverlay();
             statusEl.innerText = "Adjust green lines to match cards, then Click Start.";
             document.getElementById('processBtn').disabled = false;
        };
    }
});

function getDimensions() {
    const w = videoPlayer.videoWidth;
    const h = videoPlayer.videoHeight;
    const topPct = parseInt(document.getElementById('marginTop').value) / 100;
    const botPct = parseInt(document.getElementById('marginBottom').value) / 100;
    const sidePct = parseInt(document.getElementById('marginSide').value) / 100;

    const startX = w * sidePct;
    const endX = w * (1 - sidePct);
    const startY = h * topPct;
    const endY = h * (1 - botPct);
    
    return { w, h, startX, endX, startY, endY };
}

function drawGridOverlay() {
    if(isProcessing || !videoPlayer.videoWidth) return;
    const d = getDimensions();
    overlayCtx.clearRect(0, 0, d.w, d.h);
    
    const boxW = (d.endX - d.startX) / COLS;
    const boxH = (d.endY - d.startY) / ROWS;

    overlayCtx.strokeStyle = "#00ff00"; 
    overlayCtx.lineWidth = 3;
    overlayCtx.beginPath();

    for(let r=0; r<ROWS; r++) {
        for(let c=0; c<COLS; c++) {
            let x = d.startX + (c * boxW);
            let y = d.startY + (r * boxH);
            overlayCtx.rect(x, y, boxW, boxH);
        }
    }
    overlayCtx.stroke();
}

// --- ANALYSIS LOGIC ---
document.getElementById('processBtn').addEventListener('click', async () => {
    if(!cvReady) return;
    isProcessing = true;
    document.getElementById('processBtn').disabled = true;
    document.getElementById('btnDownload').style.display = 'none';
    
    // Define Detection Zones
    zones = [];
    const d = getDimensions();
    const boxW = (d.endX - d.startX) / COLS;
    const boxH = (d.endY - d.startY) / ROWS;

    for(let r=0; r<ROWS; r++) {
        for(let c=0; c<COLS; c++) {
            zones.push({
                id: (r*COLS) + c,
                x: Math.floor(d.startX + (c * boxW) + (boxW * 0.15)), // 15% padding
                y: Math.floor(d.startY + (r * boxH) + (boxH * 0.15)),
                w: Math.floor(boxW * 0.7), 
                h: Math.floor(boxH * 0.7),
                cx: Math.floor(d.startX + (c * boxW) + (boxW/2)), // Center X for JSON
                cy: Math.floor(d.startY + (r * boxH) + (boxH/2)), // Center Y for JSON
                locked: false
            });
        }
    }

    let cap = new cv.VideoCapture(videoPlayer);
    let frame = new cv.Mat(d.h, d.w, cv.CV_8UC4);
    let gray = new cv.Mat();
    let prevGray = new cv.Mat();
    let diff = new cv.Mat();
    
    let cooldown = 0;
    currentStep = 1;

    // Reset UI
    document.querySelectorAll('.cell').forEach(c => {
        c.className = 'cell';
        c.innerText = c.id.split('-')[1] * 1 + 1;
    });

    const interval = 1/20; // Check every ~50ms
    let currentTime = 0;
    const duration = videoPlayer.duration;

    async function loop() {
        if(currentTime >= duration) {
            statusEl.innerText = "Analysis Complete!";
            isProcessing = false;
            document.getElementById('processBtn').disabled = false;
            document.getElementById('btnDownload').style.display = 'block';
            frame.delete(); gray.delete(); prevGray.delete(); diff.delete();
            return;
        }

        // Seek video
        videoPlayer.currentTime = currentTime;
        await new Promise(r => {
             const h = () => { videoPlayer.removeEventListener('seeked', h); r(); };
             videoPlayer.addEventListener('seeked', h);
        });

        procCtx.drawImage(videoPlayer, 0, 0, d.w, d.h);
        
        // Draw locked zones red
        overlayCtx.clearRect(0, 0, d.w, d.h);
        overlayCtx.lineWidth = 3;
        zones.filter(z => z.locked).forEach(z => {
             overlayCtx.strokeStyle = "red";
             overlayCtx.strokeRect(z.x, z.y, z.w, z.h);
        });

        let src = cv.imread(procCanvas);
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

        if(!prevGray.empty() && cooldown <= 0) {
            cv.absdiff(gray, prevGray, diff);
            cv.threshold(diff, diff, 50, 255, cv.THRESH_BINARY);

            let changed = [];
            zones.forEach(z => {
                if(z.locked) return;
                let roi = diff.roi(new cv.Rect(z.x, z.y, z.w, z.h));
                let count = cv.countNonZero(roi);
                if(count > (z.w * z.h * 0.2)) changed.push(z); // 20% change threshold
                roi.delete();
            });

            // If 1 or 2 cards flip (ignore screen wipes)
            if(changed.length > 0 && changed.length <= 2) {
                let z = changed[0];
                z.locked = true;
                z.step = currentStep; // Store step for JSON
                
                const cell = document.getElementById(`c-${z.id}`);
                cell.classList.add('detected');
                cell.innerText = currentStep;
                
                currentStep++;
                cooldown = 5; // Wait 5 frames
            }
        }

        if(cooldown > 0) cooldown--;
        gray.copyTo(prevGray);
        src.delete();
        currentTime += interval;
        requestAnimationFrame(loop); // Non-blocking loop
    }
    loop();
});

// --- JSON DOWNLOAD (MATCHING FLIPIMAGE FORMAT) ---
document.getElementById('btnDownload').onclick = () => {
    // Filter only locked zones
    let steps = zones.filter(z => z.locked).map(z => ({
        step: z.step,
        x: z.cx,
        y: z.cy
    }));

    // Sort by step number
    steps.sort((a, b) => a.step - b.step);

    if (steps.length === 0) return alert("No patterns found!");

    const actionList = steps.map((s, i) => {
        return {
            "type": "TAP_COORDINATE",
            "data": `${s.x},${s.y}`,
            "extras": [
                { "id": "extra_coordinate_description", "data": `Step ${s.step}` },
                { "id": "extra_delay_before_next_action", "data": "400" } 
            ],
            "flags": 0,
            "uid": crypto.randomUUID()
        };
    });

    const keymap = {
        "app_version": 63,
        "keymap_db_version": 13,
        "fingerprint_map_list": [
            { "action_list": [], "constraints": [], "constraint_mode": 1, "extras": [], "flags": 0, "id": 0, "enabled": true },
            { "action_list": [], "constraints": [], "constraint_mode": 1, "extras": [], "flags": 0, "id": 1, "enabled": true },
            { "action_list": [], "constraints": [], "constraint_mode": 1, "extras": [], "flags": 0, "id": 2, "enabled": true },
            { "action_list": [], "constraints": [], "constraint_mode": 1, "extras": [], "flags": 0, "id": 3, "enabled": true }
        ],
        "keymap_list": [{
            "id": 1,
            "isEnabled": true,
            "uid": crypto.randomUUID(),
            "trigger": {
                "mode": 2,
                "keys": [{ "keyCode": 24, "clickType": 2, "uid": crypto.randomUUID() }]
            },
            "actionList": actionList
        }]
    };

    const blob = new Blob([JSON.stringify(keymap, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const timestamp = new Date().toISOString().replace(/T/, '_').replace(/\..+/, '').replace(/:/g, '');
    a.download = `Video_Pattern_${timestamp}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
};
</script>
</body>
</html>
