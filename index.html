<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Video Pattern Recorder - Fixed Precision</title>
    <style>
        :root { --primary: #00bcd4; --bg: #f5f6fa; --text: #2f3640; --danger: #e74c3c; --success: #2ecc71; }
        body { 
            font-family: 'Segoe UI', sans-serif; 
            background: var(--bg); 
            color: var(--text); 
            margin: 0; 
            padding: 10px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
        }
        
        .main-container { 
            background: white; 
            padding: 20px; 
            border-radius: 12px; 
            box-shadow: 0 4px 20px rgba(0,0,0,0.1); 
            max-width: 600px; 
            width: 100%; 
            box-sizing: border-box; 
        }

        .nav-header { text-align: center; margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 10px; }
        .nav-header h2 { margin: 5px 0 10px 0; color: #2c3e50; }

        .preview-wrapper { 
            position: relative; 
            width: 100%; 
            background: #000; 
            border-radius: 8px; 
            overflow: hidden; 
            margin-bottom: 15px; 
            line-height: 0; 
            border: 2px solid #333;
        }
        #videoPlayer { width: 100%; display: block; }
        #overlayCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        .control-panel { background: #fdfdfd; padding: 15px; border: 1px solid #eee; border-radius: 10px; margin-bottom: 15px; }
        
        .btn { width: 100%; padding: 12px; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; font-size: 1rem; color: white; transition: 0.2s; margin-top: 5px; }
        .btn-start { background: var(--primary); }
        .btn-start:disabled { background: #bdc3c7; cursor: not-allowed; }
        .btn-download { background: var(--success); margin-top: 15px; display: none; }
        
        input[type="file"] { width: 100%; margin-bottom: 15px; font-size: 0.9rem; }

        .results-grid { 
            display: grid; 
            grid-template-columns: repeat(4, 1fr); 
            gap: 6px; 
            margin-top: 20px; 
            width: 100%;
        }
        .cell { 
            aspect-ratio: 1; 
            background: #ecf0f1; 
            border-radius: 6px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-weight: bold; 
            font-size: 1.1rem; 
            color: #bdc3c7; 
        }
        .cell.detected { background: white; border: 2px solid var(--danger); color: var(--danger); }

        #status { text-align: center; font-size: 0.9rem; margin: 10px 0; color: #7f8c8d; }
    </style>
    <script async src="https://docs.opencv.org/4.5.4/opencv.js" onload="onOpenCvReady()"></script>
</head>
<body>

<div class="main-container">
    <div class="nav-header">
        <h2>Video Pattern Recorder</h2>
        <p style="font-size: 0.8rem; color: #666;">Using Fixed Precision Template (1260x2800)</p>
    </div>

    <input type="file" id="videoInput" accept="video/*">
    
    <div class="preview-wrapper">
        <video id="videoPlayer" muted playsinline></video>
        <canvas id="overlayCanvas"></canvas>
    </div>

    <div class="control-panel">
        <button id="processBtn" class="btn btn-start" disabled>â–¶ START SCANNING</button>
    </div>

    <div id="status">Waiting for OpenCV...</div>
    <div id="grid" class="results-grid"></div>
    <button id="btnDownload" class="btn btn-download">ðŸ’¾ DOWNLOAD PRECISION JSON</button>
</div>

<canvas id="procCanvas" style="display:none;"></canvas>

<script>
let cvReady = false;
const ROWS = 5;
const COLS = 4;
let zones = []; 
let currentStep = 1;

// THE FIXED COORDINATE TEMPLATE FROM YOUR JSON
const FIXED_COORDS = [
    "170,845",  "480,845",  "790,845",  "1100,845",
    "170,1145", "480,1145", "790,1145", "1100,1145",
    "170,1445", "480,1445", "790,1445", "1100,1445",
    "170,1745", "480,1745", "790,1745", "1100,1745",
    "170,2045", "480,2045", "790,2045", "1100,2045"
];

// Initialize Grid UI
const gridEl = document.getElementById('grid');
for(let i=0; i<20; i++) {
    let d = document.createElement('div');
    d.className = 'cell';
    d.id = `c-${i}`;
    d.innerText = i + 1;
    gridEl.appendChild(d);
}

const videoInput = document.getElementById('videoInput');
const videoPlayer = document.getElementById('videoPlayer');
const overlayCanvas = document.getElementById('overlayCanvas');
const overlayCtx = overlayCanvas.getContext('2d');
const procCanvas = document.getElementById('procCanvas');
const procCtx = procCanvas.getContext('2d', {willReadFrequently: true});
const statusEl = document.getElementById('status');

function onOpenCvReady() {
    cvReady = true;
    statusEl.innerText = "Ready. Select your screen recording.";
}

videoInput.addEventListener('change', (e) => {
    if(e.target.files[0]) {
        const url = URL.createObjectURL(e.target.files[0]);
        videoPlayer.src = url;
        videoPlayer.onloadedmetadata = () => {
            // Force canvas to match the expected precision resolution (or the video's native)
            overlayCanvas.width = videoPlayer.videoWidth;
            overlayCanvas.height = videoPlayer.videoHeight;
            procCanvas.width = videoPlayer.videoWidth;
            procCanvas.height = videoPlayer.videoHeight;
            drawStaticOverlay();
            document.getElementById('processBtn').disabled = false;
            statusEl.innerText = "Video loaded. Ready to scan.";
        };
    }
});

function drawStaticOverlay() {
    overlayCtx.clearRect(0,0, overlayCanvas.width, overlayCanvas.height);
    FIXED_COORDS.forEach((coordStr, index) => {
        const [x, y] = coordStr.split(',').map(Number);
        
        // Draw Detection Box (Area where we look for flip)
        overlayCtx.strokeStyle = "rgba(0, 255, 255, 0.6)";
        overlayCtx.lineWidth = 2;
        overlayCtx.strokeRect(x - 60, y - 60, 120, 120);

        // Draw Precision Spot (The Tap Point)
        overlayCtx.fillStyle = "yellow";
        overlayCtx.beginPath();
        overlayCtx.arc(x, y, 6, 0, Math.PI * 2);
        overlayCtx.fill();
    });
}

document.getElementById('processBtn').onclick = async () => {
    if(!cvReady) return;
    document.getElementById('processBtn').disabled = true;
    document.getElementById('btnDownload').style.display = 'none';
    statusEl.innerText = "Scanning patterns...";
    
    currentStep = 1;
    document.querySelectorAll('.cell').forEach(c => c.className = 'cell');

    // Setup scanning zones based on the FIXED_COORDS
    zones = FIXED_COORDS.map((coordStr, index) => {
        const [x, y] = coordStr.split(',').map(Number);
        return {
            id: index,
            coordString: coordStr, // Keep the exact string for JSON
            x: x - 50, // ROI for detection
            y: y - 50,
            w: 100,
            h: 100,
            locked: false,
            step: 0
        };
    });

    let cap = new cv.VideoCapture(videoPlayer);
    let gray = new cv.Mat();
    let prevGray = new cv.Mat();
    let diff = new cv.Mat();
    
    let currentTime = 0;
    const interval = 0.1;
    let cooldown = 0;

    async function processFrame() {
        if(currentTime >= videoPlayer.duration) {
            statusEl.innerText = "Complete!";
            document.getElementById('processBtn').disabled = false;
            document.getElementById('btnDownload').style.display = 'block';
            gray.delete(); prevGray.delete(); diff.delete();
            return;
        }

        videoPlayer.currentTime = currentTime;
        await new Promise(r => { videoPlayer.onseeked = r; });

        procCtx.drawImage(videoPlayer, 0, 0);
        let src = cv.imread(procCanvas);
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

        if(!prevGray.empty() && cooldown <= 0) {
            cv.absdiff(gray, prevGray, diff);
            cv.threshold(diff, diff, 45, 255, cv.THRESH_BINARY);
            
            let detected = [];
            zones.forEach(z => {
                if(z.locked) return;
                let roi = diff.roi(new cv.Rect(z.x, z.y, z.w, z.h));
                let changes = cv.countNonZero(roi);
                roi.delete();
                if(changes > (z.w * z.h * 0.15)) detected.push(z);
            });

            if(detected.length > 0 && detected.length <= 2) {
                let target = detected[0];
                target.locked = true;
                target.step = currentStep;
                
                document.getElementById(`c-${target.id}`).classList.add('detected');
                document.getElementById(`c-${target.id}`).innerText = currentStep;
                
                currentStep++;
                cooldown = 4; 
            }
        }

        if(cooldown > 0) cooldown--;
        gray.copyTo(prevGray);
        src.delete();
        currentTime += interval;
        requestAnimationFrame(processFrame);
    }
    processFrame();
};

document.getElementById('btnDownload').onclick = () => {
    const steps = zones.filter(z => z.locked).sort((a,b) => a.step - b.step);
    
    const actionList = steps.map(s => ({
        "type": "TAP_COORDINATE",
        "data": s.coordString, // USES THE EXACT FIXED COORDINATE STRING
        "extras": [
            { "id": "extra_coordinate_description", "data": String(s.step) },
            { "id": "extra_delay_before_next_action", "data": 120 }
        ],
        "flags": 0,
        "uid": crypto.randomUUID()
    }));

    const keymapData = {
        "app_version": 63,
        "keymap_db_version": 13,
        "fingerprint_map_list": [
            { "action_list": [], "constraints": [], "constraint_mode": 1, "extras": [], "flags": 0, "id": 0, "enabled": true },
            { "action_list": [], "constraints": [], "constraint_mode": 1, "extras": [], "flags": 0, "id": 1, "enabled": true },
            { "action_list": [], "constraints": [], "constraint_mode": 1, "extras": [], "flags": 0, "id": 2, "enabled": true },
            { "action_list": [], "constraints": [], "constraint_mode": 1, "extras": [], "flags": 0, "id": 3, "enabled": true }
        ],
        "keymap_list": [{
            "actionList": actionList,
            "constraintList": [],
            "constraintMode": 1,
            "flags": 0,
            "id": 27,
            "isEnabled": true,
            "trigger": {
                "extras": [],
                "flags": 1,
                "keys": [{
                    "clickType": 2,
                    "deviceId": "io.github.sds100.keymapper.THIS_DEVICE",
                    "flags": 0,
                    "keyCode": 24, // Volume Up
                    "uid": crypto.randomUUID()
                }],
                "mode": 2
            },
            "uid": crypto.randomUUID()
        }]
    };

    const blob = new Blob([JSON.stringify(keymapData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `Precision_Pattern_${new Date().getTime()}.json`;
    a.click();
};
</script>
</body>
</html>
